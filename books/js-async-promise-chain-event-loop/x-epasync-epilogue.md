---
title: "エピローグ"
---

# あとがき
ここまで読んでいただきありがとうございました。

Zenn で本を作るのは初めてなので色々な反省点があります。

「理解度 60 ~ 70% 程度で先に書き始めてしまう」というのが自分のスタイルなのですが、これによって学習や理解が飛躍的に進むというのが大きなメリットである一方で、勘違いや間違いなどが後から見つかるケースが非常に多いので頻繁に内容を修正する羽目になります。

この本についても、最初から完全な理解に基づいた上でしっかり構成を考えて作ったわけではなく、以前に書いた「学習ロードマップ」の記事から逆算して重要度や誤解を起こしやすいポイントからなんとなくのストーリーラインを作ってライブ感で作成したというのが実情です(この本を書くこと自体が学習プロセスに組み込まれているので、そういうやり方をしたという理由もあります)。

なので正直に言えば、作成プロセスの時点から「本」というよりは「記事の集合」あるいは「かなり長い記事をチャプターに断片化したもの」として捉えてしまった方が良いです。非連続でチャプターを書いた結果、先のチャプターの内容で後のチャプターの知識を前提としてしまっている場合も中にはありました。

肝心の「非同期処理」についてですが、これは JavaScript の初学者が確実につまずくポイントとなっています。個人の意見というよりも、そういう仕組みになっていると言った方が正しいのではないでしょうか。ECMAScript の非同期機能に目が行くのは当然で、`fetch()` や `setTimeout()` などの Web API が Promise や async/await によって見逃されてしまい、非同期 API と非同期処理の話がごっちゃになるようになっています。「非同期処理」が非同期 API とコールバックなどの話でひとくくりに認識されるので、かなり厄介であるこの罠に気づけません。

更に、環境に注目する必要があることも気づくのが難しいです。学習を進めれば必然的にそこに注目しなくてはいけないことが分かるのですが、自分はたまたまブラウザからではなく、Node や Deno から主な学習を始めるというやり方で、複数の環境を最初から前提にできたこともあり、環境の相違点や共通点、環境に埋め込まれたコンポーネント群について比較的早めに意識することもできました。

自分が非同期処理についての学習を始めた際には、そういったことについて断片的な情報しか得られない場合が多く、「なぜ非同期処理をするのか、どういう仕組みで、なぜそういう実行順序になるのかについて複数の環境において包括的に理解する」というような１つのストーリーで詳細に解説しているものを見つけることができませんでした。上で挙げたようなトラップについて実際には自分もかなり引っかかったので、こういったトラップについて早期に気づけるようなドキュメントもあったらいいなと考えて作り始めました。

大きな目的として「学習者にとって簡単すぎず仕様に近すぎない抽象度で１つのストーリーとして理解したい」という過去の自分のために書いたのが、この一冊です。

過去の時点で自分が知りたかったことを書いているとはいえ、自分と同じように非同期処理を理解しようと悪戦苦闘している方々のお役に立てれば幸いです。

# 宣伝
せっかくなので、最後に自分が初めて翻訳に関わったツールである Obisidian について宣伝しておきます。

最近は忙しくてあまりドキュメントなどの保守ができていませんが、個人のためのナレッジベース(PKM: Personal Knowlege Base)を作るモダンなマークダウンメモツールである Obsidian を是非使ってみてください(ちなみに Electron で開発されており、モバイルも含めてクロスプラットフォームで使えます)。

https://obsidian.md

Obsidian についての紹介記事はこちらになります。

https://zenn.dev/estra/articles/ohzflow-zenn-hugo-obsidian

この本を書いたり、非同期処理についての学習をするのにも非常に役立ちました。Zenn との相性もかなり高いのでぜひとも使ってみて広げてください。控えめに言って最高です。

