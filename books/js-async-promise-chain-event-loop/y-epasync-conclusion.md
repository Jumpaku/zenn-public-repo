---
title: "総括 - 非同期処理のまとめ"
---

# このチャプターについて

大変お疲れ様でした。「非同期処理」の話はこれにて終了となります。

ここまで「非同期処理」にまつわる様々な事柄について学んできましたが、最終チャプターとして主な話題についての総括と振り返りを行っておきたい思います。具体的なコードは使わずに目的や理由をまとめておきます。

# 概念は組み合わせて理解する

「非同期処理、同期処理、非同期 API、並列、並行、逐次」といったこれらの言葉や概念は非常に紛らわしいですが、「非同期処理の全体の仕組み」を理解する上では**全部使います**。全部使うというのは、言葉のまま、全部のタイプの概念や処理が組み合わされることで大きくくくられる「非同期処理」の仕組みが実現されるということです。

# イベントループによる並行処理
「非同期処理」を理解するための核心はイベントループであり、この機構こそが非同期にまつわるシンタックスで書かれた処理を実現させています。

これは非同期処理の実行順序を理解する上では避けて通ることのできない非常に重要な概念であり、根本的に非同期処理を実現させるために必要な機構です。

イベントループの機構によってコールバック関数などの単位で処理を切り替えることので並行(concurrent)処理が実現されます。それらのコールバック関数は並行で処理される訳ですから、ソースコードの配置とずれて非同期的に実行されることになります。そしてコールバック関数はタスクかマイクロタスクとして処理される訳ですが、それぞれで実行されるタイミングや考え方が異なります。

タスクやマイクロタスクはそれぞれ専用のキューを持っていますが、そのキューに配置されたタスクとマイクロタスクは特定のタイミングでコールスタックと呼ばれるところに順番に配置されて、コールスタックのトップとなったときに処理されることになります。そして、タスクやマイクロタスクの実体は実行コンテキストでした。

そして、イベントループにおけるミソは、これらの**タスクやマイクロタスクの連鎖的な処理**です。非同期処理では制御によってどのように逐次処理を実現していくかが重要になりますが、タスクやマイクロタスクを連鎖的に発行されることで時間的に非連続になる可能性のある逐次処理を実現していきます。

:::details 参照チャプター
- 『[それぞれのイベントループ](c-epasync-what-event-loop)』
- 『[イベントループは内部にネストしたループがある](13-epasync-loop-is-nested)』
- 『[コールスタックと実行コンテキスト](b-epasync-callstack-execution-context)』
- 『[タスクキューとマイクロタスクキュー](d-epasync-task-microtask-queues)』
:::

# 非同期 API による並列的作業
実際には「非同期」という概念は「**複数の関連する事象が前の事象の完了を待たずに起きる**」ことを意味し、非同期 API そのものの性質を指し示していました。この「非同期」の現象は他の「同期」処理コードなどが存在しているときに限って発現しました。イベントループ機構により並行処理されるコールバックなどはこの非同期 API の利用に基づく現象に付随してタイミングがずれてしまうものでした。

この非同期 API は「**Non-blocking API**」とも呼ばれメインスレッドをブロッキングすることなく並列的に時間のかかる処理を環境がバックグラウンドで代行してくれました。API は ECMAScript の一部ではなく、環境から提供される機能だったわけです。

JavaScript はメインスレッドという単一スレッド(シングルスレッド)で実行されるという話でもありましたが、「非同期処理」の目的はこの時間のかかる処理を環境にバックグラウンドでおこなわせている間もメインスレッドで別の作業ができるようにすることでした。

本質的には「時間の良い」非同期 API を利用したいからわざわざ「非同期処理」という制御の難しいことをやるわけです。ブラウザ環境ならメインスレッドは UI スレッドであり、レンダリング処理もこのメインスレッドで行われている訳ですから、長時間かかるような API 処理でスレッドをブロッキングしてしまうとユーザーがなにもできない時間ができるので更にシビアな問題になります。

そして、非同期 API は直接タスクを発行する古いタイプのものや、Promise インスタンスを返し間接的にマイクロタスクを発行する新しいタイプのものなどがありました。後者は Promise-based API と呼ばれ、モダンな非同期処理の根幹となるものです。

:::details 参照チャプター
- 『[非同期 API と環境](f-epasync-asynchronous-apis)』
- 『[それぞれのイベントループ](c-epasync-what-event-loop)』
- 『[タスクキューとマイクロタスクキュー](d-epasync-task-microtask-queues)』
:::
# すべては効率の良い非同期 API を使いたいがため
`setTimeout()` といったタスクを発行するタスクベースの API や、`fetch()` といった Promise インスタンスを返して関節的にマイクロタスクを発行するマイクロタスクベースの API を利用したいがために、Callback や Promise、async/await などを書いていくことになります。

結局のところ、そういった非同期にまつわる ECMAScript のシンタックスは「効率の良い」非同期 API の絡む処理がしたいから書かざる負えないものであり、制御が難しいので非同期 API を使わなくて良い場合にはわざわざ書く必要がありません。

「非同期処理」というテーマでは、目的そのものが「効率の良い非同期 API」を使うことにありますが、その際に発生するコード配置と実行順序がずれてしまう「後続の関連処理」をいかに記述するかという点が主な学習対象となる領域です。そして、非同期 API の処理を起点とした一連の処理手順(逐次処理)の順序を保証することこそが非同期処理の制御では重要です。

:::details 参照チャプター
- 『[同期 API とブロッキング](f-epasync-synchronus-apis)』
:::

# 非同期 API の後続処理を制御するためのシンタックス

非同期 API を使う際にはタイミングがズレてしまうコードを記述するための上記のシンタックス(Promise や async/await)を利用しなくてはいけません。具体的に、は非同期 API の処理を行ったあとにその API 処理から取得したデータなどを使った関連する後続処理を制御するために非同期のシンタックスを書くことになります。

実際には、async/await は Promise のシステムに基づき Promise を扱う Promise 処理の利便性を向上させるものでした。特に async 関数では Promise を扱っていることを意識する必要があります。つまり、async/await が主役なのではなく、あくまで Promise が主役というわけです。


非同期 API を起点とした一連の処理手順を正しく保証するためには、適切な Promise chain の構築や await 式の配置を行う必要があります。それらを適切に行うことで、意図した処理の順序付けや並列化により効率化して処理を制御できます。並列化する際には、実際には非同期 API 処理を並列化していることに注意してください。

:::details 参照チャプター
- 『[Promise チェーンから async 関数へ](14-epasync-chain-to-async-await)』
- 『[コールバックで副作用となる非同期処理](10-epasync-dont-use-side-effect)』
- 『[Promise の静的メソッドと並列化](17-epasync-static-method)』
- 『[反復処理の制御](19-epasync-async-loop)』
:::

# TypeScript は型を上乗せするだけ

TypeScirpt は JavaScript に型システムを導入した言語ですが、本質的にはより良い JavaScript を書くためのツール(リンター)に過ぎません。非同期処理を理解するためには JavaScript の実行環境や非同期 API、ECMAScript のシンタックスへの理解が欠かせません。

TypeScript によって上乗せされる型情報は本質的には非同期処理と関係がないものですが、モダンな開発では扱うデータの具象性を上げて堅牢でスケーラブルなコードを書くために学ぶ必要があります。

:::details 参照チャプター
- 『[TypeScript における Promise の型注釈](j-epasync-ts-promise-type-annotation)』
:::

# まとめ

以上が「非同期処理」というテーマの話となりました。かなり長く壮大なテーマでしたが、裏側の原理や本質的な部分を押さえることで非同期処理の実行順序の制御のみならず、JavaScript や環境への理解を深めることができたと思います。

また、ECMAScript や JavaScsript、TypeScript などの境界線を意識することもできた思います。これによって、今後わからないことがあればどの領域の話なのか追求できるようになったと思います。

自分自身、非同期処理というテーマを通して様々なことを学ぶことができたと思っていますが、読んでくださった方も同様にこのテーマを通して多くのものを学ぶことができたと感じていただければ大変嬉しく思います。

ここまでお疲れ様でした。また、長い文章を読んで頂き誠にありがとう御座いました。最後のページはあとがきとなります。

